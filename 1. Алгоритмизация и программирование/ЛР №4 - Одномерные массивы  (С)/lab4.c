 /*
 
 Лабораторная работа №4
 
 Вариант 26
 
 Заданы размер массива, действительные значения его элементов и количество элементов в группе (от 2 до 15). 
 Дополнить каждую группу исходного массива еще одним элементом, который содержит наибольший общий делитель 
 элементов группы. Неполная группа должна быть дополнена нулями.
 
*/

#include <stdio.h>
#include <math.h>
#include <locale.h>
#include <stdlib.h>

int main() {
    double array[32] = {0};
/*
 Максимальное кол-во элементов: 20
 Максимальное кол-во элементов в группе: 15 => Будет 2 группы.
 в одной группе будет не хватать 10 элементов
 => 30 элементов в 2-ух группах и 2 элемента под запись результата
 30 + 2 = 32
 */
 
    int n = 0, group = 0;
    int i = 0, j = 0;
    
    // n - количество элементов
    //group - количество элементов в группе 
  
 setlocale(LC_ALL, "rus");
        
    printf("Введите кол-во элементов (Не больше 20): ");
    while (scanf("%d", &n) != 1 || n < 0 || n > 20) {
        printf("Некорректный ввод, попробуй снова\n");
        while (getchar() != '\n'); // очистка буфера ввода
    }
        
    printf("Введите кол-во групп (Не больше 15): ");
    while (scanf("%d", &group) != 1 || group < 2 || group > 15) {
        printf("Некорректный ввод, попробуй снова\n");
        while (getchar() != '\n'); // очистка буфера ввода
    }
    // 
    int new = n + (n / group); // (n / group) - кол-во групп. Сколько групп - столько индексов для записи результата

    int cnt = 0; // Счётчик, который отвечает за кол-во обработанных элементов
    for (i = 0; i < new; i += group + 1) {
        for (j = 0; j < group && cnt != n; j++, cnt++) {
            printf("Введите %d значение \n", cnt + 1);
            if (!scanf("%lf", &array[i + j])) {
                char ch;
                printf("Некорекный ввод, попробуй снова\n");
                while (((ch = getchar()) != '\n') && (ch != EOF));
                j--, cnt--;   
                //Мы уменьшаем j и cnt при некорректном вводе, т.е возвращаемся на тот же элемент на котором произошёл некорректный ввод
            }
        }
    }

    printf("Исходный массив:\n");
    for (j = 0; j < i; j++) {
        printf("%.2lf ", array[j]);
    }
    putchar('\n');//просто printf только для одного символа

    cnt = 0;
    for (i = 0; i < new; i += group + 1) {
        double result = array[i]; // Изначально записываем в результат первый элемент группы
        for (j = 1; j < group && cnt != n; j++, cnt++) { // Начинаем обработку группы не с 1-ого элемента, а со второго!
            double b = array[i + j]; // Буферная переменная, используется что-бы не изменить исходное число в массиве
            
            /*Алгоритм Евклида*/
            while (result != 0 && b != 0) {
                if (result > b) {
                    result = fmod(result, b); //fmod - остаток от деления для вещественных чисел
                } else {
                    b = fmod(b, result);
                }
            }
            result += b;
        }

        /*В конце обработки группы записывем результат*/
        array[i + group] = result;
    }

    printf("Конечный массив:\n");
    for (j = 0; j < i; j++) {
        printf("%.2lf ", array[j]);
    }
    putchar('\n');
    
    system("pause");
    return 0;
}

